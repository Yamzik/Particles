#pragma once
namespace src
{
	const char* particleFragment =
		"#version 430 core										\n"
		"in vec2 particlePos;									\n"
		"in vec4 particleColor;									\n"
		"out vec4 fc;											\n"
		"uniform float diameter;								\n"
		"uniform vec2 resolution;								\n"
		"void main()											\n"
		"{														\n"
		"	vec2 dot = vec2(									\n"
		"		/*(gl_FragCoord.x / 1920.0 - particlePos.x),	\n"
		"		(gl_FragCoord.y / 1080.0 - particlePos.y)*/		\n"
		"		(gl_FragCoord.x / 800.0 - particlePos.x),		\n"
		"		(gl_FragCoord.y / 800.0 - particlePos.y)		\n"
		"	);													\n"
		"	dot.x = abs(dot.x);									\n"
		"	dot.y = abs(dot.y);									\n"
		"	if (length(dot) < diameter / 1600.0)				\n"
		"		fc = vec4(particleColor);						\n"
		"	else discard;										\n"
		"};														\n";
	const char* particleVertex =
		"#version 430 core										\n"
		"layout(location = 0) in vec2 aPos;						\n"
		"layout(location = 1) in vec2 aVelocity;				\n"
		"layout(location = 2) in vec2 aForce;					\n"
		"layout(location = 3) in vec2 aColorRG;					\n"
		"layout(location = 4) in vec2 aColorBA;					\n"
		"														\n"
		"out vec2 particlePos;									\n"
		"out vec4 particleColor;								\n"
		"														\n"
		"uniform float diameter;								\n"
		"														\n"
		"void main()											\n"
		"{														\n"
		"	vec2 actualPos = (aPos + 1.0) / 2.0;				\n"
		"	gl_PointSize = diameter;							\n"
		"	gl_Position = vec4(aPos, 0.0, 1.0);					\n"
		"	particlePos = actualPos;							\n"
		"	particleColor = vec4(aColorRG, aColorBA);			\n"
		"}														\n";
	const char* particleCompute =
		"#version 430 core																			 \n"
		"																							 \n"
		"struct Particle {																			 \n"
		"vec2 position;																				 \n"
		"vec2 velocity;																				 \n"
		"vec2 force;																				 \n"
		"vec2 rg;																					 \n"
		"vec2 ba;																					 \n"
		"vec2 diameter_mass;																		 \n"
		"float id;																					 \n"
		"int color;																					 \n"
		"};																							 \n"
		"																							 \n"
		"layout(std430, binding = 0) buffer float_buffer {											 \n"
		"	Particle data[];																		 \n"
		"};																							 \n"
		"layout(std430, binding = 1) buffer check_buffer {											 \n"
		"	float checks[];																			 \n"
		"};																							 \n"
		"																							 \n"
		"layout(local_size_x = 1) in;																 \n"
		"																							 \n"
		"uniform int particles_number;																 \n"
		"uniform int stage; // 0 - force; 1 - velocity + position;									 \n"
		"uniform float max_attraction;																 \n"
		"uniform float attraction_coeff;															 \n"
		"uniform float max_repultion;																 \n"
		"uniform float repultion_coeff;																 \n"
		"uniform float viscocity_coeff;																 \n"
		"uniform float max_force;																	 \n"
		"uniform float friction_coeff;																 \n"
		"																							 \n"
		"float dt = 0.016;																			 \n"
		"																							 \n"
		"highp float rand(vec2 co) {															     \n"
		"	highp float a = 12.9898;																 \n"
		"	highp float b = 78.233;																	 \n"
		"	highp float c = 43758.5453;																 \n"
		"	highp float dt = dot(co.xy, vec2(a, b));												 \n"
		"	highp float sn = mod(dt, 3.14);															 \n"
		"	return fract(sin(sn) * c);																 \n"
		"}																							 \n"
		"																							 \n"
		"vec2 viscosity_law(Particle P)																 \n"
		"{																							 \n"
		"	return P.velocity * 0.785375 * pow(P.diameter_mass.x, 2) * viscocity_coeff;				 \n"
		"}																							 \n"
		"vec2 attraction_law(Particle A, Particle B) {												 \n"
		"	vec2 AB = B.position - A.position;														 \n"
		"	float radii_avg = (A.diameter_mass.y + B.diameter_mass.y) / 2.0;						 \n"
		"	float numerator = A.diameter_mass.x * B.diameter_mass.x;								 \n"
		"	float denominator = pow(length(AB) + radii_avg, 2.0);									 \n"
		"	float force = attraction_coeff * numerator / denominator;								 \n"
		"	float result = min(force, max_attraction);												 \n"
		"	return normalize(AB) * result;															 \n"
		"}																							 \n"
		"vec2 repultion_law(Particle A, Particle B) {												 \n"
		"	vec2 AB = B.position - A.position;														 \n"
		"	float radii_avg = (A.diameter_mass.y + B.diameter_mass.y) / 2.0;						 \n"
		"	float numerator = A.diameter_mass.x * B.diameter_mass.x;								 \n"
		"	float denominator = pow(length(AB) + radii_avg, 5.0);									 \n"
		"	float force = -repultion_coeff * numerator / denominator;								 \n"
		"	float result = min(force, max_repultion);												 \n"
		"	return normalize(AB) * result;															 \n"
		"}																							 \n"
		"vec2 friction_law(Particle P)																 \n"
		"{																							 \n"
		"	float force = length(P.force);															 \n"
		"	force = force - P.diameter_mass.y * friction_coeff;										 \n"
		"	if (force <= 0)																			 \n"
		"		return vec2(0.0f);																	 \n"
		"	else																					 \n"
		"	{																						 \n"
		"		return normalize(P.force) * force;													 \n"
		"	}																						 \n"
		"}																							 \n"
		"vec2 clamp_force(Particle P)																 \n"
		"{																							 \n"
		"	float force = length(P.force);															 \n"
		"	if (force > max_force)																	 \n"
		"		return P.force * max_force / force;													 \n"
		"	return P.force;																			 \n"
		"}																							 \n"
		"																							 \n"
		"void main() {																				 \n"
		"	uint ident = gl_GlobalInvocationID.x;													 \n"
		"	if (stage == 0)																			 \n"
		"	{																						 \n"
		"		data[ident].force = viscosity_law(data[ident]);										 \n"
		"	}																						 \n"
		"	if (stage == 1)																			 \n"
		"	{																						 \n"
		"		for (int i = 0;																		 \n"
		"			i < particles_number;															 \n"
		"			i++) {																			 \n"
		"			if (ident != i) {																 \n"
		"				data[ident].force += attraction_law(data[ident], data[i]);					 \n"
		"				data[ident].force += repultion_law(data[ident], data[i]);					 \n"
		"			}																				 \n"
		"		}																					 \n"
		"	}																						 \n"
		"	if (stage == 2)																			 \n"
		"	{																						 \n"
		"		data[ident].force = friction_law(data[ident]);										 \n"
		"		data[ident].force = clamp_force(data[ident]);										 \n"
		"	}																						 \n"
		"	if (stage == 3)																			 \n"
		"	{																						 \n"
		"		data[ident].velocity += dt * data[ident].force / data[ident].diameter_mass.y;		 \n"
		"																							 \n"
		"		vec2 position = data[ident].position + data[ident].velocity * dt;					 \n"
		"		if (position.x > 1 || position.x < -1)												 \n"
		"		{																					 \n"
		"			data[ident].force.x = -data[ident].force.x;										 \n"
		"			data[ident].velocity.x = -data[ident].velocity.x;								 \n"
		"		}																					 \n"
		"		if (position.y > 1 || position.y < -1)												 \n"
		"		{																					 \n"
		"			data[ident].force.y = -data[ident].force.y;										 \n"
		"			data[ident].velocity.y = -data[ident].velocity.y;								 \n"
		"		}																					 \n"
		"		data[ident].position += data[ident].velocity * dt;									 \n"
		"	}																						 \n"
		"}																							 \n";
}